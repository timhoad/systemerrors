<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Can You Handle The Truth?</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=OCR+A+Std&display=swap" rel="stylesheet">
  <style>
    /* General Styles */
    body {
      font-family: 'OCR A Std', sans-serif;
      background: #1a1a1a;
      color: white;
      margin: 0;
      padding: 0;
    }

    .crt {
      position: relative;
      width: 100%;
      height: 100vh;
      background: #000;
      border: 5px solid #00ff00;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
    }

    .letters-container {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      z-index: 10;
    }

    .drop-zone {
      position: absolute;
      bottom: 20%;
      width: 100%;
      display: flex;
      justify-content: center;
      z-index: 5;
    }

    .drop-row {
      display: flex;
      justify-content: center;
    }

    .drop-slot {
      width: 40px;
      height: 40px;
      margin: 5px;
      border: 2px solid #00ff00;
      background: transparent;
      text-align: center;
      line-height: 40px;
      font-size: 1.5rem;
      color: white;
    }

    .draggable-letter {
      position: absolute;
      color: white;
      font-weight: bold;
      font-size: 2rem;
      cursor: grab;
      animation: pulse 3s infinite ease-in-out;
      user-select: none;
      touch-action: none;
    }

    .filled {
      background: #00ff00;
      color: black;
    }

    /* Animation */
    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
      100% {
        transform: scale(1);
      }
    }

    /* Completion overlay */
    .completion-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .completion-message {
      font-size: 2rem;
      color: white;
      text-align: center;
      padding: 20px;
    }

    .form-container {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      color: white;
      z-index: 15;
    }

    input {
      margin: 10px;
      padding: 10px;
      font-size: 1rem;
      color: black;
    }

    button {
      padding: 10px;
      font-size: 1rem;
      color: black;
      background-color: #00ff00;
    }
  </style>
</head>
<body>
  <div class="crt" id="riddle-box">
    <div id="riddle-text"></div><span class="cursor" id="riddle-cursor"></span>
  </div>

  <div class="letters-container" id="letters-container"></div>

  <div class="drop-zone" id="drop-zone">
    <div class="drop-row" id="row1"></div>
    <div class="drop-row" id="row2"></div>
  </div>

  <div class="form-container" id="form-container">
    <h3>Start pulling the strings here</h3>
    <p>access - knowledge, tools for critical thinking, breakdowns, product activism</p>
    <input type="email" placeholder="Email">
    <input type="text" placeholder="First Name">
    <input type="text" placeholder="Surname">
    <input type="text" placeholder="Country">
    <button>Stand Together</button>
  </div>

  <div class="completion-overlay" id="completion-overlay">
    <div class="completion-message" id="final-message"></div><span class="completion-cursor"></span>
  </div>

  <script>
    const phrase = "CAN YOU HANDLE THE TRUTH?";
    const cleanPhrase = phrase.replace(/\s/g, '');
    const letters = cleanPhrase.split('').sort(() => Math.random() - 0.5);
    const container = document.getElementById('letters-container');
    const row1 = document.getElementById('row1');
    const row2 = document.getElementById('row2');
    let correctCount = 0;

    function addSlots(row, text) {
      for (const char of text) {
        if (char === ' ') {
          const spacer = document.createElement('div');
          spacer.style.width = '15px';
          row.appendChild(spacer);
        } else {
          const slot = document.createElement('div');
          slot.classList.add('drop-slot');
          row.appendChild(slot);
        }
      }
    }

    addSlots(row1, "CAN YOU HANDLE");
    addSlots(row2, "THE TRUTH?");

    const letterPositions = [];

    function getRandomPosition() {
      let position;
      let isOverlap = true;
      while (isOverlap) {
        position = {
          x: Math.random() * 90,
          y: Math.random() * 90,
        };
        isOverlap = letterPositions.some(p => Math.abs(p.x - position.x) < 10 && Math.abs(p.y - position.y) < 10);
      }
      letterPositions.push(position);
      return position;
    }

    const slots = document.querySelectorAll('.drop-slot');

    function triggerFinalMessage() {
      const overlay = document.getElementById('completion-overlay');
      const message = document.getElementById('final-message');
      const text = "you persevered, where most donâ€™t even try...";
      let index = 0;
      overlay.style.display = 'flex';

      function typeMessage() {
        if (index < text.length) {
          message.textContent += text[index];
          index++;
          setTimeout(typeMessage, 70);
        }
      }

      setTimeout(typeMessage, 500);
    }

    function handleCompletion() {
      setTimeout(() => {
        triggerFinalMessage();
      }, 500);
    }

    letters.forEach((char, i) => {
      const letter = document.createElement('div');
      letter.classList.add('draggable-letter');
      letter.textContent = char;
      letter.dataset.index = i;

      const { x, y } = getRandomPosition();
      letter.style.left = `${x}%`;
      letter.style.top = `${y}%`;

      letter.setAttribute('draggable', true);

      // Variables for touch tracking
      let offsetX, offsetY;

      // Touch start: Track initial touch position
      letter.addEventListener('touchstart', e => {
        const touch = e.touches[0];
        const rect = letter.getBoundingClientRect();
        offsetX = touch.clientX - rect.left;
        offsetY = touch.clientY - rect.top;
        letter.style.zIndex = 1000; // Bring to front during drag
        letter.style.transition = 'none'; // Disable transition during drag

        // Play audio on touch
        const touchAudio = new Audio('your-audio-file.mp3');
        touchAudio.play();
      });

      // Touch move: Track finger and prevent the letter from shooting away
      letter.addEventListener('touchmove', e => {
        e.preventDefault(); // Prevent default behavior like scrolling
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;

        // Keep letter under the finger and update position
        letter.style.left = `${touchX - offsetX}px`;
        letter.style.top = `${touchY - offsetY}px`;
      });

      // Touch end: Lock position and snap letter to the placeholder if needed
      letter.addEventListener('touchend', e => {
        const touch = e.changedTouches[0];
        const dropX = touch.clientX;
        const dropY = touch.clientY;
        const originalIndex = letter.dataset.index;
        const char = letter.textContent;

        slots.forEach((slot, index) => {
          const rect = slot.getBoundingClientRect();
          const correctChar = cleanPhrase[index];
          if (
            dropX > rect.left && dropX < rect.right &&
            dropY > rect.top && dropY < rect.bottom &&
            !slot.classList.contains('filled') &&
            char === correctChar
          ) {
            slot.textContent = char;
            slot.classList.add('filled');
            slot.style.animation = 'glitch 0.3s ease-out';
            setTimeout(() => { slot.style.animation = ''; }, 300);
            letter.style.display = 'none';
            correctCount++;
            if (correctCount === cleanPhrase.length) {
              handleCompletion();
            }
          }
        });

        letter.style.zIndex = '';
        letter.style.transition = '';
      });

      container.appendChild(letter);
    });

    slots.forEach((slot, index) => {
      slot.addEventListener('dragover', e => e.preventDefault());
      slot.addEventListener('drop', e => {
        const droppedChar = e.dataTransfer.getData('text/plain');
        const originalIndex = e.dataTransfer.getData('index');
        const correctChar = cleanPhrase[index];
        if (droppedChar === correctChar && !slot.classList.contains('filled')) {
          slot.textContent = droppedChar;
          slot.classList.add('filled');
          slot.style.animation = 'glitch 0.3s ease-out';
          setTimeout(() => { slot.style.animation = ''; }, 300);
          const letterDiv = document.querySelector(`.draggable-letter[data-index='${originalIndex}']`);
          letterDiv.style.display = 'none';
          correctCount++;
          if (correctCount === cleanPhrase.length) {
            handleCompletion();
          }
        }
      });
    });
  </script>
</body>
</html>